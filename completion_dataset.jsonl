{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .", "suffix": "\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "populate('user', { username: 1, name: 1 })", "meta": {"lines": "7:6-7:48"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).", "suffix": "\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "end()", "meta": {"lines": "12:70-12:75"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) r", "suffix": "\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "equest.body.likes = 0", "meta": {"lines": "13:47-13:68"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({", "suffix": "\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })", "meta": {"lines": "19:26-25:5"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n", "suffix": "})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "\n  response.status(201).json(newBlog)\n", "meta": {"lines": "31:1-33:1"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    ", "suffix": "}\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  ", "meta": {"lines": "41:5-43:3"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.b", "suffix": "\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "logs.filter(blog => blog !== blogToBeDeleted.id)", "meta": {"lines": "45:22-45:70"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).j", "suffix": "})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog, { new: true })\n  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": "son({ error: 'User does not have permission to delete the blog' })\n", "meta": {"lines": "47:25-48:1"}}
{"file": "bloglist/controllers/blogs.js", "prefix": "const blogsRouter = require('express').Router()\nconst Blog = require('../models/blog')\n\n\nblogsRouter.get('/', async (request, response) => {\n  const blogs = await Blog.find({})\n    .populate('user', { username: 1, name: 1 })\n  response.json(blogs)\n})\n\nblogsRouter.post('/', async (request, response) => {\n  if (!request.body.title || !request.body.url) response.status(400).end()\n  if (!request.body.hasOwnProperty('likes')) request.body.likes = 0\n\n  const body = request.body\n\n  const user = await request.user\n\n  const blog = new Blog({\n    title: body.title,\n    url: body.url,\n    author: body.author,\n    likes: body.likes,\n    user: user.id\n  })\n\n  const newBlog = await blog.save()\n\n  user.blogs = user.blogs.concat(newBlog._id)\n  await user.save()\n\n  response.status(201).json(newBlog)\n})\n\nblogsRouter.delete('/:id', async (request, response) => {\n\n  const blogToBeDeleted = await Blog.findById(request.params.id)\n  const user = request.user\n\n  if (blogToBeDeleted.user.toString() === user.id) {\n    await Blog.findByIdAndDelete(blogToBeDeleted.id)\n    return response.status(204).end()\n  }\n  console.log(user.id)\n  user.blogs = user.blogs.filter(blog => blog !== blogToBeDeleted.id)\n  await user.save()\n  response.status(401).json({ error: 'User does not have permission to delete the blog' })\n})\n\nblogsRouter.put('/:id', async (request, response) => {\n  const body = request.body\n  const blog = {\n    title: body.title,\n    author: body.author,\n    likes: body.likes,\n    url: body.url,\n  }\n\n  const returnedBlog = await Blog.findByIdAndUpdate(request.params.id, blog,", "suffix": "  if (!returnedBlog) response.status(404).end()\n  response.json(returnedBlog)\n})\n\nmodule.exports = blogsRouter", "middle": " { new: true })\n", "meta": {"lines": "59:77-60:1"}}
{"file": "bloglist/controllers/users.js", "prefix": "const User = require('../models/user')\nconst userRouter = require(\"express\").Router();\nconst bcrypt = require(\"bcrypt\");\n\nuserRouter.post('/', async (request, response) => {\n  const { username, name, password } = request.body\n", "suffix": "\n  const passwordHash = await bcrypt.hash(password, 10)\n\n  const user = new User({\n    username: username,\n    name: name,\n    passwordHash: passwordHash,\n  })\n\n  const savedUser = await user.save()\n\n  response.status(201).json(savedUser)\n})\n\nuserRouter.get('/', async (request, response) => {\n  const users = await User.find({}).\n  populate('blogs', { url: 1, title: 1, author: 1 })\n  response.json(users)\n})\n\nmodule.exports = userRouter", "middle": "  if (password.length <= 3) {\n    return response.status(400).json({ error: 'password too short' })\n  }\n", "meta": {"lines": "7:1-10:1"}}
{"file": "bloglist/controllers/users.js", "prefix": "const User = require('../models/user')\nconst userRouter = require(\"express\").Router();\nconst bcrypt = require(\"bcrypt\");\n\nuserRouter.post('/', async (request, response) => {\n  const { username, name, password } = request.body\n  if (password.length <= 3) {\n    return response.status(400).json({ error: 'password too short' })\n  }\n\n  const passwordHash = await ", "suffix": "\n  const user = new User({\n    username: username,\n    name: name,\n    passwordHash: passwordHash,\n  })\n\n  const savedUser = await user.save()\n\n  response.status(201).json(savedUser)\n})\n\nuserRouter.get('/', async (request, response) => {\n  const users = await User.find({}).\n  populate('blogs', { url: 1, title: 1, author: 1 })\n  response.json(users)\n})\n\nmodule.exports = userRouter", "middle": "bcrypt.hash(password, 10)\n", "meta": {"lines": "11:30-12:1"}}
{"file": "bloglist/controllers/users.js", "prefix": "const User = require('../models/user')\nconst userRouter = require(\"express\").Router();\nconst bcrypt = require(\"bcrypt\");\n\nuserRouter.post('/', async (request, response) => {\n  const { username, name, password } = request.body\n  if (password.length <= 3) {\n    return response.status(400).json({ error: 'password too short' })\n  }\n\n  const passwordHash = await bcrypt.hash(password, 10)\n\n  const user = ", "suffix": "\n  const savedUser = await user.save()\n\n  response.status(201).json(savedUser)\n})\n\nuserRouter.get('/', async (request, response) => {\n  const users = await User.find({}).\n  populate('blogs', { url: 1, title: 1, author: 1 })\n  response.json(users)\n})\n\nmodule.exports = userRouter", "middle": "new User({\n    username: username,\n    name: name,\n    passwordHash: passwordHash,\n  })\n", "meta": {"lines": "13:16-18:1"}}
{"file": "bloglist/controllers/users.js", "prefix": "const User = require('../models/user')\nconst userRouter = require(\"express\").Router();\nconst bcrypt = require(\"bcrypt\");\n\nuserRouter.post('/', async (request, response) => {\n  const { username, name, password } = request.body\n  if (password.length <= 3) {\n    return response.status(400).json({ error: 'password too short' })\n  }\n\n  const passwordHash = await bcrypt.hash(password, 10)\n\n  const user = new User({\n    username: username,\n    name: name,\n    passwordHash: passwordHash,\n  })\n\n  const savedUser = await user.save()\n\n  response.status(201).json(savedUser)\n})\n\nuserRouter.get('/', async (request, response) => {\n  const users = await User.find({}).\n  ", "suffix": "\n  response.json(users)\n})\n\nmodule.exports = userRouter", "middle": "populate('blogs', { url: 1, title: 1, author: 1 })", "meta": {"lines": "26:3-26:53"}}
{"file": "bloglist/tests/user_api.test.js", "prefix": "const { test, after, beforeEach, describe } = require('node:test')\nlet mongoose = require('mongoose')\nconst assert = require('assert')\nconst app = require('../app')\nconst supertest = require('supertest')\nconst User = require('../models/user')\nconst helper = require('./test_helper')\nconst api = supertest(app)\n\n\ndescribe('invalid user add tests', () => {\n\n  beforeEach(async () => {\n    await User.deleteMany({})\n\n", "suffix": "\n    await defaultUser.save()\n  })\n  test('user with too short a user name', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'ts',\n      name: 'Short username',\n      password: 'a strong password'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('username too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtStart.length, usersAtEnd.length)\n  })\n\n  test('user with too short a password', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'temp username',\n      name: 'temp username',\n      password: '12'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('password too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n  test('user with existing username', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'root',\n      name: 'temp username',\n      password: 'astrongpassword'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('username expected to be unique'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n})\n\nafter(async () => {\n  mongoose.connection.close()\n})\n", "middle": "    const defaultUser = new User({\n      username: 'root',\n      name: 'SuperUser',\n      password: 'astrongpassword'\n    })\n", "meta": {"lines": "16:1-21:1"}}
{"file": "bloglist/tests/user_api.test.js", "prefix": "const { test, after, beforeEach, describe } = require('node:test')\nlet mongoose = require('mongoose')\nconst assert = require('assert')\nconst app = require('../app')\nconst supertest = require('supertest')\nconst User = require('../models/user')\nconst helper = require('./test_helper')\nconst api = supertest(app)\n\n\ndescribe('invalid user add tests', () => {\n\n  beforeEach(async () => {\n    await User.deleteMany({})\n\n    const defaultUser = new User({\n      username: 'root',\n      name: 'SuperUser',\n      password: 'astrongpassword'\n    })\n\n    await defaultUser.save()\n  })\n  test('user with too short a user name', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {", "suffix": "\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('username too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtStart.length, usersAtEnd.length)\n  })\n\n  test('user with too short a password', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'temp username',\n      name: 'temp username',\n      password: '12'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('password too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n  test('user with existing username', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'root',\n      name: 'temp username',\n      password: 'astrongpassword'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('username expected to be unique'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n})\n\nafter(async () => {\n  mongoose.connection.close()\n})\n", "middle": "\n      username: 'ts',\n      name: 'Short username',\n      password: 'a strong password'\n    }\n", "meta": {"lines": "27:22-32:1"}}
{"file": "bloglist/tests/user_api.test.js", "prefix": "const { test, after, beforeEach, describe } = require('node:test')\nlet mongoose = require('mongoose')\nconst assert = require('assert')\nconst app = require('../app')\nconst supertest = require('supertest')\nconst User = require('../models/user')\nconst helper = require('./test_helper')\nconst api = supertest(app)\n\n\ndescribe('invalid user add tests', () => {\n\n  beforeEach(async () => {\n    await User.deleteMany({})\n\n    const defaultUser = new User({\n      username: 'root',\n      name: 'SuperUser',\n      password: 'astrongpassword'\n    })\n\n    await defaultUser.save()\n  })\n  test('user with too short a user name', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'ts',\n      name: 'Short username',\n      password: 'a strong password'\n    }\n\n    const response = await api.post('/api/users')", "suffix": "\n    assert(response.body.error.includes('username too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtStart.length, usersAtEnd.length)\n  })\n\n  test('user with too short a password', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'temp username',\n      name: 'temp username',\n      password: '12'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('password too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n  test('user with existing username', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'root',\n      name: 'temp username',\n      password: 'astrongpassword'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('username expected to be unique'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n})\n\nafter(async () => {\n  mongoose.connection.close()\n})\n", "middle": "\n      .send(newUser)\n      .expect(400)\n", "meta": {"lines": "33:50-36:1"}}
{"file": "bloglist/tests/user_api.test.js", "prefix": "const { test, after, beforeEach, describe } = require('node:test')\nlet mongoose = require('mongoose')\nconst assert = require('assert')\nconst app = require('../app')\nconst supertest = require('supertest')\nconst User = require('../models/user')\nconst helper = require('./test_helper')\nconst api = supertest(app)\n\n\ndescribe('invalid user add tests', () => {\n\n  beforeEach(async () => {\n    await User.deleteMany({})\n\n    const defaultUser = new User({\n      username: 'root',\n      name: 'SuperUser',\n      password: 'astrongpassword'\n    })\n\n    await defaultUser.save()\n  })\n  test('user with too short a user name', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'ts',\n      name: 'Short username',\n      password: 'a strong password'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n", "suffix": "\n  })\n\n  test('user with too short a password', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'temp username',\n      name: 'temp username',\n      password: '12'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('password too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n  test('user with existing username', async () => {\n    const usersAtStart = await helper.getUsersInDb()\n\n    const newUser = {\n      username: 'root',\n      name: 'temp username',\n      password: 'astrongpassword'\n    }\n\n    const response = await api.post('/api/users')\n      .send(newUser)\n      .expect(400)\n\n    assert(response.body.error.includes('username expected to be unique'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtEnd.length, usersAtStart.length)\n  })\n\n})\n\nafter(async () => {\n  mongoose.connection.close()\n})\n", "middle": "    assert(response.body.error.includes('username too short'))\n    const usersAtEnd = await helper.getUsersInDb()\n    assert.strictEqual(usersAtStart.length, usersAtEnd.length)", "meta": {"lines": "37:1-39:63"}}
{"file": "bloglist/models/user.js", "prefix": "const mongoose = require('mongoose');\n\nconst userSchema = mongoose.Schema({\n  username: {\n    type: String,\n    required: true,\n    minlength: 3,\n    unique: true\n  },\n  name: String,\n  passwordHash: String,\n  blogs: [\n    {\n      type:mongoose.Schema.Types.ObjectId,\n      ref: 'Blog'\n    }\n  ]\n})\n\nuserSchema.set('toJSON',", "suffix": "\nmodule.exports = mongoose.model('User', userSchema)", "middle": " {\n  transform: (document, returnedObject) => {\n    returnedObject.id = returnedObject._id.toString()\n    delete returnedObject._id\n    delete returnedObject.__v\n    delete returnedObject.passwordHash\n  }\n})\n", "meta": {"lines": "20:25-28:1"}}
{"file": "bloglist/utils/middleware.js", "prefix": "const logger = require(\"./logger\")\nconst jwt = require(\"jsonwebtoken\")\nconst User = require(\"../models/user\")\n\nconst tokenExtractor = (request, response, next) => {\n  const authorization = request.get('Authorization')\n  if (authorization) {\n    request.token = authorization.replace('Bearer ', '')\n  }\n  next()\n}\n\nconst userExtractor = async (request, response, next) => {\n  const decodedToken = jwt.decode(request.token)\n  if (decodedToken) {\n    request.user = await User.findById(decodedToken.id)\n  }\n  next()\n}\n\nconst unknownEndpoint = (request, response) => {\n  response.status(404).send({ error: 'unknown endpoint' })\n}\n\nconst errorHandler = (err, req, res, next) => {\n  logger.error(err.message)\n\n", "suffix": "\n  res.status(500).json({ error: err.name })\n}\n\nmodule.exports = {\n  errorHandler,\n  unknownEndpoint,\n  userExtractor,\n  tokenExtractor\n}", "middle": "  if (err.name === 'ValidationError') {\n    res.status(400).json({ error: 'username too short' })\n  } else if (err.message.includes('E11000 duplicate key error')) {\n    res.status(400).json({ error: 'username expected to be unique' })\n  } else if (err.name === 'TokenExpiredError') {\n    res.status(401).json({ error: 'token expired' })\n  } else if (err.name === 'CastError') {\n    res.status(400).json({ error: 'illegal id' })\n  } else if (err.message.includes('Cannot read properties of')) {\n    res.status(401).json({ error: 'Authorization invalid' })\n  }", "meta": {"lines": "28:1-38:4"}}
{"file": "parallel-programming/noparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value)\n            row.push_back(value);\n        matrix.push_back(row);\n    }\n\n    int V = matrix.size();\n    for(int i=0; i<V; ++i) {\n        for(int j=0; j<V; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int, int>>& neighbors = G.getEdges(node);\n\n    ", "suffix": "\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n\n    return cost;\n}\n\nvoid branchAndBound(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &minCost) {\n    if (currentCost >= minCost) {\n        return;\n    }\n\n    if (countA > selA || countA + (V - index) < selA) {\n        return;\n    }\n\n    if (index == V) {\n        minCost = min(minCost, currentCost);\n        return;\n    }\n\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBound(G, flags, index + 1, countA + 1, currentCost + costIncreaseA, minCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBound(G, flags, index + 1, countA, currentCost + costIncreaseB, minCost);\n\n    flags[index] = -1;\n}\n\nint main() {\n    V = 30;\n    Graph g(V);\n    vector<int> flags(V, -1);\n    int minCost = numeric_limits<int>::max();\n    selA = 15;\n\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    clock_t start = clock();\n\n    branchAndBound(g, flags, 0, 0, 0, minCost);\n    cout << \"Minimum cut cost: \" << minCost << endl;\n\n    clock_t stop = clock();\n    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "for (const auto& neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n", "meta": {"lines": "89:5-97:1"}}
{"file": "parallel-programming/noparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value)\n            row.push_back(value);\n        matrix.push_back(row);\n    }\n\n    int V = matrix.size();\n    for(int i=0; i<V; ++i) {\n        for(int j=0; j<V; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int, int>>& neighbors = G.getEdges(node);\n\n    for (const auto& neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n\n    ", "suffix": "\n    return cost;\n}\n\nvoid branchAndBound(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &minCost) {\n    if (currentCost >= minCost) {\n        return;\n    }\n\n    if (countA > selA || countA + (V - index) < selA) {\n        return;\n    }\n\n    if (index == V) {\n        minCost = min(minCost, currentCost);\n        return;\n    }\n\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBound(G, flags, index + 1, countA + 1, currentCost + costIncreaseA, minCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBound(G, flags, index + 1, countA, currentCost + costIncreaseB, minCost);\n\n    flags[index] = -1;\n}\n\nint main() {\n    V = 30;\n    Graph g(V);\n    vector<int> flags(V, -1);\n    int minCost = numeric_limits<int>::max();\n    selA = 15;\n\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    clock_t start = clock();\n\n    branchAndBound(g, flags, 0, 0, 0, minCost);\n    cout << \"Minimum cut cost: \" << minCost << endl;\n\n    clock_t stop = clock();\n    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n", "meta": {"lines": "98:5-103:1"}}
{"file": "parallel-programming/noparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value)\n            row.push_back(value);\n        matrix.push_back(row);\n    }\n\n    int V = matrix.size();\n    for(int i=0; i<V; ++i) {\n        for(int j=0; j<V; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int, int>>& neighbors = G.getEdges(node);\n\n    for (const auto& neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n\n    return cost;\n}\n\nvoid branchAndBound(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &minCost) {\n    if (currentCost >= minCost) {\n        return;\n    }\n\n    if (countA > selA || countA + (V - index) < selA) {\n        return;\n    }\n\n    if (index == V) {\n        minCost = min(minCost, currentCost);\n        return;\n    }\n", "suffix": "    flags[index] = -1;\n}\n\nint main() {\n    V = 30;\n    Graph g(V);\n    vector<int> flags(V, -1);\n    int minCost = numeric_limits<int>::max();\n    selA = 15;\n\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    clock_t start = clock();\n\n    branchAndBound(g, flags, 0, 0, 0, minCost);\n    cout << \"Minimum cut cost: \" << minCost << endl;\n\n    clock_t stop = clock();\n    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBound(G, flags, index + 1, countA + 1, currentCost + costIncreaseA, minCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBound(G, flags, index + 1, countA, currentCost + costIncreaseB, minCost);\n\n", "meta": {"lines": "120:1-129:1"}}
{"file": "parallel-programming/noparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n", "suffix": "\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value)\n            row.push_back(value);\n        matrix.push_back(row);\n    }\n\n    int V = matrix.size();\n    for(int i=0; i<V; ++i) {\n        for(int j=0; j<V; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int, int>>& neighbors = G.getEdges(node);\n\n    for (const auto& neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n\n    return cost;\n}\n\nvoid branchAndBound(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &minCost) {\n    if (currentCost >= minCost) {\n        return;\n    }\n\n    if (countA > selA || countA + (V - index) < selA) {\n        return;\n    }\n\n    if (index == V) {\n        minCost = min(minCost, currentCost);\n        return;\n    }\n\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBound(G, flags, index + 1, countA + 1, currentCost + costIncreaseA, minCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBound(G, flags, index + 1, countA, currentCost + costIncreaseB, minCost);\n\n    flags[index] = -1;\n}\n\nint main() {\n    V = 30;\n    Graph g(V);\n    vector<int> flags(V, -1);\n    int minCost = numeric_limits<int>::max();\n    selA = 15;\n\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    clock_t start = clock();\n\n    branchAndBound(g, flags, 0, 0, 0, minCost);\n    cout << \"Minimum cut cost: \" << minCost << endl;\n\n    clock_t stop = clock();\n    double elapsed = (double)(stop - start) / CLOCKS_PER_SEC;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n", "meta": {"lines": "31:1-40:1"}}
{"file": "parallel-programming/taskparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i < j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int,int>>& neighbors = G.getEdges(node);\n\n    for (const auto &neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\nvoid branchAndBoundSerial(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &bestCost)\n{\n    if (currentCost >= bestCost) return;\n    if (countA > selA || countA + (V - index) < selA) return;\n\n    if (index == V) {\n        if (currentCost < bestCost) {\n            bestCost = currentCost;\n        }\n        return;\n    }\n\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBoundSerial(G, flags, index + 1, countA + 1,\n                         currentCost + costIncreaseA, bestCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBoundSerial(G, flags, index + 1, countA,\n                         currentCost + costIncreaseB, bestCost);\n\n    flags[index] = -1;\n}\n\n\nstatic const int MAX_DEPTH_PARALLEL = 8;\n\nvoid branchAndBoundParallel(const Graph &G, vector<int> flags,\n                            int index, int countA, int currentCost, int &globalMinCost, int depth) {\n    int localMinCost;\n    #pragma omp atomic read\n    localMinCost = globalMinCost;\n\n    if (currentCost >= localMinCost) return;\n    if (countA > selA || countA + (V - index) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < globalMinCost) {\n                globalMinCost = currentCost;\n            }\n        }\n        return;\n    }\n\n    if (depth < MAX_DEPTH_PARALLEL) {\n        flags[index] = 0;\n        int costA = calculateCost(G, flags, index, 0);\n        #pragma omp task default(none) \\\n                         shared(G, globalMinCost) \\\n                         firstprivate(flags, index, countA, currentCost, depth, costA)\n        {\n            branchAndBoundParallel(G, flags, index + 1,\n                                   countA + 1,\n                                   currentCost + costA,\n                                   globalMinCost,\n                                   depth + 1);\n        }\n\n        flags[index] = 1;\n        int costB = calculateCost(G, flags, index, 1);\n        #pragma omp task default(none) \\\n                         shared(G, globalMinCost) \\\n                         firstprivate(flags, index, countA, currentCost, depth, costB)\n        {\n            branchAndBoundParallel(G, flags, index + 1,\n                                   countA,\n                                   currentCost + costB,\n                                   globalMinCost,\n                                   depth + 1);\n        }\n    }\n    ", "suffix": "    }\n    else {\n        flags[index] = 0;\n        int costA = calculateCost(G, flags, index, 0);\n        branchAndBoundSerial(G, flags, index + 1, countA + 1, currentCost + costA, globalMinCost);\n\n        flags[index] = 1;\n        int costB = calculateCost(G, flags, index, 1);\n        branchAndBoundSerial(G, flags, index + 1, countA, currentCost + costB, globalMinCost);\n    }\n    #pragma omp taskwait\n}\n\n\nint main() {\n    V = 30;\n    selA = 15;\n\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    vector<int> flags(V, -1);\n    int globalMinCost = numeric_limits<int>::max();\n\n    double start = omp_get_wtime();\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            branchAndBoundParallel(g, flags, 0, 0, 0, globalMinCost,0);\n        }\n    }\n\n    cout << \"Minimum cut cost: \" << globalMinCost << endl;\n    double stop = omp_get_wtime();\n    double elapsed = stop - start;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "else {\n", "meta": {"lines": "180:5-179:1"}}
{"file": "parallel-programming/taskparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i < j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int,int>>& neighbors = G.getEdges(node);\n\n    for (const auto &neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\nvoid branchAndBoundSerial(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &bestCost)\n{\n    if (currentCost >= bestCost) return;\n    if (countA > selA || countA + (V - index) < selA) return;\n\n    if (index == V) {\n        if (currentCost < bestCost) {\n            bestCost = currentCost;\n        }\n        return;\n    }\n\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBoundSerial(G, flags, index + 1, countA + 1,\n                         currentCost + costIncreaseA, bestCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBoundSerial(G, flags, index + 1, countA,\n                         currentCost + costIncreaseB, bestCost);\n\n    flags[index] = -1;\n}\n\n\nstatic const int MAX_DEPTH_PARALLEL = 8;\n\nvoid branchAndBoundParallel(const Graph &G, vector<int> flags,\n                            int index, int countA, int currentCost, int &globalMinCost, int depth) {\n    int localMinCost;\n    #pragma omp atomic read\n    localMinCost = globalMinCost;\n\n    if (currentCost >= localMinCost) return;\n    if (countA > selA || countA + (V - index) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < globalMinCost) {\n                globalMinCost = currentCost;\n            }\n        }\n        return;\n    }\n\n    if (depth < MAX_DEPTH_PARALLEL) {\n        flags[index] = 0;\n        int costA = calculateCost(G, flags, index, 0);\n        ", "suffix": "    #pragma omp taskwait\n}\n\n\nint main() {\n    V = 30;\n    selA = 15;\n\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    vector<int> flags(V, -1);\n    int globalMinCost = numeric_limits<int>::max();\n\n    double start = omp_get_wtime();\n\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            branchAndBoundParallel(g, flags, 0, 0, 0, globalMinCost,0);\n        }\n    }\n\n    cout << \"Minimum cut cost: \" << globalMinCost << endl;\n    double stop = omp_get_wtime();\n    double elapsed = stop - start;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "#pragma omp task default(none) \\\n                         shared(G, globalMinCost) \\\n                         firstprivate(flags, index, countA, currentCost, depth, costA)\n        {\n            branchAndBoundParallel(G, flags, index + 1,\n                                   countA + 1,\n                                   currentCost + costA,\n                                   globalMinCost,\n                                   depth + 1);\n        }\n\n        flags[index] = 1;\n        int costB = calculateCost(G, flags, index, 1);\n        #pragma omp task default(none) \\\n                         shared(G, globalMinCost) \\\n                         firstprivate(flags, index, countA, currentCost, depth, costB)\n        {\n            branchAndBoundParallel(G, flags, index + 1,\n                                   countA,\n                                   currentCost + costB,\n                                   globalMinCost,\n                                   depth + 1);\n        }\n    }\n    else {\n        flags[index] = 0;\n        int costA = calculateCost(G, flags, index, 0);\n        branchAndBoundSerial(G, flags, index + 1, countA + 1, currentCost + costA, globalMinCost);\n\n        flags[index] = 1;\n        int costB = calculateCost(G, flags, index, 1);\n        branchAndBoundSerial(G, flags, index + 1, countA, currentCost + costB, globalMinCost);\n    }\n", "meta": {"lines": "156:9-189:1"}}
{"file": "parallel-programming/taskparallel.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <sstream>\n#include <time.h>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint selA = 5;\nint V = 10;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) {\n        this->V = V;\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n\n    [[nodiscard]] const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n\n    [[nodiscard]] int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n\n    [[nodiscard]] int getVertexCount() const  {\n        return V;\n    }\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    vector<vector<int>> matrix;\n    string line;\n\n    getline(infile, line);\n\n    while(getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while(ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i < j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    int cost = 0;\n    const vector<pair<int,int>>& neighbors = G.getEdges(node);\n\n    for (const auto &neighbor : neighbors) {\n        int neighborNode = neighbor.first;\n        int weight = neighbor.second;\n        if (flags[neighborNode] != -1 && flags[neighborNode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\nvoid branchAndBoundSerial(const Graph &G, vector<int> &flags, int index, int countA, int currentCost, int &bestCost)\n{\n    if (currentCost >= bestCost) return;\n    if (countA > selA || countA + (V - index) < selA) return;\n\n    if (index == V) {\n        if (currentCost < bestCost) {\n            bestCost = currentCost;\n        }\n        return;\n    }\n\n    flags[index] = 0;\n    int costIncreaseA = calculateCost(G, flags, index, 0);\n    branchAndBoundSerial(G, flags, index + 1, countA + 1,\n                         currentCost + costIncreaseA, bestCost);\n\n    flags[index] = 1;\n    int costIncreaseB = calculateCost(G, flags, index, 1);\n    branchAndBoundSerial(G, flags, index + 1, countA,\n                         currentCost + costIncreaseB, bestCost);\n\n    flags[index] = -1;\n}\n\n\nstatic const int MAX_DEPTH_PARALLEL = 8;\n\nvoid branchAndBoundParallel(const Graph &G, vector<int> flags,\n                            int index, int countA, int currentCost, int &globalMinCost, int depth) {\n    int localMinCost;\n    #pragma omp atomic read\n    localMinCost = globalMinCost;\n\n    if (currentCost >= localMinCost) return;\n    if (countA > selA || countA + (V - index) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < globalMinCost) {\n                globalMinCost = currentCost;\n            }\n        }\n        return;\n    }\n\n    if (depth < MAX_DEPTH_PARALLEL) {\n        flags[index] = 0;\n        int costA = calculateCost(G, flags, index, 0);\n        #pragma omp task default(none) \\\n                         shared(G, globalMinCost) \\\n                         firstprivate(flags, index, countA, currentCost, depth, costA)\n        {\n            branchAndBoundParallel(G, flags, index + 1,\n                                   countA + 1,\n                                   currentCost + costA,\n                                   globalMinCost,\n                                   depth + 1);\n        }\n\n        flags[index] = 1;\n        int costB = calculateCost(G, flags, index, 1);\n        #pragma omp task default(none) \\\n                         shared(G, globalMinCost) \\\n                         firstprivate(flags, index, countA, currentCost, depth, costB)\n        {\n            branchAndBoundParallel(G, flags, index + 1,\n                                   countA,\n                                   currentCost + costB,\n                                   globalMinCost,\n                                   depth + 1);\n        }\n    }\n    else {\n        flags[index] = 0;\n        int costA = calculateCost(G, flags, index, 0);\n        branchAndBoundSerial(G, flags, index + 1, countA + 1, currentCost + costA, globalMinCost);\n\n        flags[index] = 1;\n        int costB = calculateCost(G, flags, index, 1);\n        branchAndBoundSerial(G, flags, index + 1, countA, currentCost + costB, globalMinCost);\n    }\n    #pragma omp taskwait\n}\n\n\nint main() {\n    V = 30;\n    selA = 15;\n\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    vector<int> flags(V, -1);\n    int globalMinCost = numeric_limits<int>::max();\n\n    double start = omp_get_wtime();\n", "suffix": "\n    cout << \"Minimum cut cost: \" << globalMinCost << endl;\n    double stop = omp_get_wtime();\n    double elapsed = stop - start;\n    printf(\"\\nTime elapsed: %.5f\\n\", elapsed);\n\n    return 0;\n}\n", "middle": "\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            branchAndBoundParallel(g, flags, 0, 0, 0, globalMinCost,0);\n        }\n    }\n", "meta": {"lines": "206:1-214:1"}}
{"file": "parallel-programming/dataparallelsim.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint V = 30;\nint selA = 15;\nint ENOUGH_STATES = 10000;\n\n\nstatic int  g_bestCost  = numeric_limits<int>::max();\nstatic vector<int> g_bestFlags;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int,int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) : V(V) {\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n    const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n    int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n    int getVertexCount() const {\n        return V;\n    }\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto &edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n};\n\nstruct BnBState {\n    vector<int> flags;\n    int index;\n    int countA;\n    int cost;\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    string line;\n    getline(infile, line);\n\n    vector<vector<int>> matrix;\n    while (getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while (ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = (int)matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    // Same as task parallel\n    int cost = 0;\n    const auto &neighbors = G.getEdges(node);\n    for (auto &nbr : neighbors) {\n        int nnode  = nbr.first;\n        int weight = nbr.second;\n        if (flags[nnode] != -1 && flags[nnode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\n\nvoid resAlmostSeqSubTree(const Graph &G, vector<int> &flags, int index, int countA, int currentCost)\n{\n    // almost same as task parallel\n    if (currentCost >= g_bestCost) return;\n    if (countA > selA || (countA + (V - index)) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < g_bestCost) {\n                g_bestCost  = currentCost;\n                g_bestFlags = flags;\n            }\n        }\n        return;\n    }\n", "suffix": "\n    flags[index] = -1;\n}\n\nvector<BnBState> buildPartialStates(const Graph &G, int enoughStates, int maxDepth) {\n    vector<BnBState> result;\n    queue<BnBState> Q;\n\n    BnBState init;\n    init.flags  = vector<int>(V, -1);\n    init.index  = 0;\n    init.countA = 0;\n    init.cost   = 0;\n    Q.push(init);\n\n    while (!Q.empty()) {\n        BnBState s = Q.front();\n        Q.pop();\n\n        if (s.index >= maxDepth || s.index == V) {\n            result.push_back(s);\n        }\n        else {\n            {\n                BnBState s0 = s;\n                s0.flags[s0.index] = 0;\n                int cInc = calculateCost(G, s0.flags, s0.index, 0);\n                s0.cost   += cInc;\n                s0.countA += 1;\n                s0.index  += 1;\n                // Prune\n                if (s0.cost < g_bestCost && s0.countA <= selA) {\n                    Q.push(s0);\n                }\n            }\n\n            {\n                BnBState s1 = s;\n                s1.flags[s1.index] = 1;\n                int cInc = calculateCost(G, s1.flags, s1.index, 1);\n                s1.cost  += cInc;\n                s1.index += 1;\n                // Prune\n                if (s1.cost < g_bestCost) {\n                    Q.push(s1);\n                }\n            }\n        }\n\n        if ((int)result.size() >= enoughStates) break;\n    }\n\n    return result;\n}\n\nint main() {\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    g_bestFlags.resize(V, -1);\n\n    double start = omp_get_wtime();\n\n    // BFS\n    int BFS_DEPTH = 8;\n    vector<BnBState> partialStates = buildPartialStates(g, ENOUGH_STATES, BFS_DEPTH);\n\n    cout << \"Generated \" << partialStates.size()\n         << \" partial states from BFS.\\n\";\n\n    // recursion on each partial state\n    #pragma omp parallel for schedule(dynamic)\n    for (int i = 0; i < (int)partialStates.size(); i++) {\n        BnBState st = partialStates[i];\n        // weird result one time, so i created a local variable instead of directly passing st.flags\n        vector<int> localFlags = st.flags;\n        resAlmostSeqSubTree(g, localFlags, st.index, st.countA, st.cost);\n    }\n\n    double stop = omp_get_wtime();\n\n    cout << \"\\nMinimum cut cost: \" << g_bestCost << endl;\n    cout << \"\\nTime: \" << (stop - start) << \" seconds\\n\";\n\n    return 0;\n}\n", "middle": "\n    flags[index] = 0;\n    {\n        int cInc = calculateCost(G, flags, index, 0);\n        resAlmostSeqSubTree(G, flags, index + 1, countA + 1, currentCost + cInc);\n    }\n\n    flags[index] = 1;\n    {\n        int cInc = calculateCost(G, flags, index, 1);\n        resAlmostSeqSubTree(G, flags, index + 1, countA, currentCost + cInc);\n    }\n", "meta": {"lines": "129:1-141:1"}}
{"file": "parallel-programming/dataparallelsim.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint V = 30;\nint selA = 15;\nint ENOUGH_STATES = 10000;\n\n\nstatic int  g_bestCost  = numeric_limits<int>::max();\nstatic vector<int> g_bestFlags;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int,int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) : V(V) {\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n    const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n    int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n    int getVertexCount() const {\n        return V;\n    }\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto &edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n};\n\nstruct BnBState {\n    vector<int> flags;\n    int index;\n    int countA;\n    int cost;\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    string line;\n    getline(infile, line);\n\n    vector<vector<int>> matrix;\n    while (getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while (ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = (int)matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    // Same as task parallel\n    int cost = 0;\n    const auto &neighbors = G.getEdges(node);\n    for (auto &nbr : neighbors) {\n        int nnode  = nbr.first;\n        int weight = nbr.second;\n        if (flags[nnode] != -1 && flags[nnode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\n\nvoid resAlmostSeqSubTree(const Graph &G, vector<int> &flags, int index, int countA, int currentCost)\n{\n    // almost same as task parallel\n    if (currentCost >= g_bestCost) return;\n    if (countA > selA || (countA + (V - index)) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < g_bestCost) {\n                g_bestCost  = currentCost;\n                g_bestFlags = flags;\n            }\n        }\n        return;\n    }\n\n    flags[index] = 0;\n    {\n        int cInc = calculateCost(G, flags, index, 0);\n        resAlmostSeqSubTree(G, flags, index + 1, countA + 1, currentCost + cInc);\n    }\n\n    flags[index] = 1;\n    {\n        int cInc = calculateCost(G, flags, index, 1);\n        resAlmostSeqSubTree(G, flags, index + 1, countA, currentCost + cInc);\n    }\n\n    flags[index] = -1;\n}\n\nvector<BnBState> buildPartialStates(const Graph &G, int enoughStates, int maxDepth) {\n    vector<BnBState> result;\n    queue<BnBState> Q;\n\n    BnBState init;\n    init.flags  = vector<int>(V, -1);\n    init.index  = 0;\n    init.countA = 0;\n    init.cost   = 0;\n    Q.push(init);\n\n    while (!Q.empty()) {\n        BnBState s = Q.front();\n        Q.pop();\n\n        if (s.index >= maxDepth || s.index == V) {\n            result.push_back(s);\n        }\n        else {\n            {\n                BnBState s0 = s;\n                s0.flags[s0.index] = 0;\n                int cInc = calculateCost(G, s0.flags, s0.index, 0);\n                s0.cost   += cInc;\n                s0.countA += 1;\n                s0.index  += 1;\n                // Prune\n                if (s0.cost < g_bestCost && s0.countA <= selA) {\n                    Q.push(s0);\n                }\n            }\n\n            {\n                BnBState s1 = s;\n                s1.flags[s1.index] = 1;\n                int cInc = calculateCost(G, s1.flags, s1.index, 1);\n                s1.cost  += cInc;\n                s1.index += 1;\n                // Prune\n                if (s1.cost < g_bestCost) {\n                    Q.push(s1);\n                }\n            }\n        }\n\n        if ((int)result.size() >= enoughStates) break;\n    }\n\n    return result;\n}\n\nint main() {\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    g_bestFlags.resize(V, -1);\n\n    double start = omp_get_wtime();\n\n    // BFS\n    int BFS_DEPTH = 8;\n    vector<BnBState> partialStates = buildPartialStates(g, ENOUGH_STATES, BFS_DEPTH);\n\n    cout << \"Generated \" << partialStates.size()\n         << \" partial states from BFS.\\n\";\n", "suffix": "\n    double stop = omp_get_wtime();\n\n    cout << \"\\nMinimum cut cost: \" << g_bestCost << endl;\n    cout << \"\\nTime: \" << (stop - start) << \" seconds\\n\";\n\n    return 0;\n}\n", "middle": "\n    // recursion on each partial state\n    #pragma omp parallel for schedule(dynamic)\n    for (int i = 0; i < (int)partialStates.size(); i++) {\n        BnBState st = partialStates[i];\n        // weird result one time, so i created a local variable instead of directly passing st.flags\n        vector<int> localFlags = st.flags;\n        resAlmostSeqSubTree(g, localFlags, st.index, st.countA, st.cost);\n    }\n", "meta": {"lines": "212:1-221:1"}}
{"file": "parallel-programming/dataparallelsim.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint V = 30;\nint selA = 15;\nint ENOUGH_STATES = 10000;\n\n\nstatic int  g_bestCost  = numeric_limits<int>::max();\nstatic vector<int> g_bestFlags;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int,int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) : V(V) {\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n    const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n    int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n    int getVertexCount() const {\n        return V;\n    }\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto &edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n};\n\nstruct BnBState {\n    vector<int> flags;\n    int index;\n    int countA;\n    int cost;\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    string line;\n    getline(infile, line);\n\n    vector<vector<int>> matrix;\n    while (getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while (ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = (int)matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    // Same as task parallel\n    int cost = 0;\n    const auto &neighbors = G.getEdges(node);\n    for (auto &nbr : neighbors) {\n        int nnode  = nbr.first;\n        int weight = nbr.second;\n        if (flags[nnode] != -1 && flags[nnode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\n\nvoid resAlmostSeqSubTree(const Graph &G, vector<int> &flags, int index, int countA, int currentCost)\n{\n    // almost same as task parallel\n    if (currentCost >= g_bestCost) return;\n    if (countA > selA || (countA + (V - index)) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < g_bestCost) {\n                g_bestCost  = currentCost;\n                g_bestFlags = flags;\n            }\n        }\n        return;\n    }\n\n    flags[index] = 0;\n    {\n        int cInc = calculateCost(G, flags, index, 0);\n        resAlmostSeqSubTree(G, flags, index + 1, countA + 1, currentCost + cInc);\n    }\n\n    flags[index] = 1;\n    {\n        int cInc = calculateCost(G, flags, index, 1);\n        resAlmostSeqSubTree(G, flags, index + 1, countA, currentCost + cInc);\n    }\n\n    flags[index] = -1;\n}\n\nvector<BnBState> buildPartialStates(const Graph &G, int enoughStates, int maxDepth) {\n    vector<BnBState> result;\n    queue<BnBState> Q;\n\n    BnBState init;\n    init.flags  = vector<int>(V, -1);\n    init.index  = 0;\n    init.countA = 0;\n    init.cost   = 0;\n    Q.push(init);\n\n    while (!Q.empty()) {\n        BnBState s = Q.front();\n        Q.pop();\n\n        if (s.index >= maxDepth || s.index == V) {\n            result.push_back(s);\n        }\n        else {\n", "suffix": "        }\n\n        if ((int)result.size() >= enoughStates) break;\n    }\n\n    return result;\n}\n\nint main() {\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    g_bestFlags.resize(V, -1);\n\n    double start = omp_get_wtime();\n\n    // BFS\n    int BFS_DEPTH = 8;\n    vector<BnBState> partialStates = buildPartialStates(g, ENOUGH_STATES, BFS_DEPTH);\n\n    cout << \"Generated \" << partialStates.size()\n         << \" partial states from BFS.\\n\";\n\n    // recursion on each partial state\n    #pragma omp parallel for schedule(dynamic)\n    for (int i = 0; i < (int)partialStates.size(); i++) {\n        BnBState st = partialStates[i];\n        // weird result one time, so i created a local variable instead of directly passing st.flags\n        vector<int> localFlags = st.flags;\n        resAlmostSeqSubTree(g, localFlags, st.index, st.countA, st.cost);\n    }\n\n    double stop = omp_get_wtime();\n\n    cout << \"\\nMinimum cut cost: \" << g_bestCost << endl;\n    cout << \"\\nTime: \" << (stop - start) << \" seconds\\n\";\n\n    return 0;\n}\n", "middle": "            {\n                BnBState s0 = s;\n                s0.flags[s0.index] = 0;\n                int cInc = calculateCost(G, s0.flags, s0.index, 0);\n                s0.cost   += cInc;\n                s0.countA += 1;\n                s0.index  += 1;\n                // Prune\n                if (s0.cost < g_bestCost && s0.countA <= selA) {\n                    Q.push(s0);\n                }\n            }\n\n            {\n                BnBState s1 = s;\n                s1.flags[s1.index] = 1;\n                int cInc = calculateCost(G, s1.flags, s1.index, 1);\n                s1.cost  += cInc;\n                s1.index += 1;\n                // Prune\n                if (s1.cost < g_bestCost) {\n                    Q.push(s1);\n                }\n            }\n", "meta": {"lines": "164:1-188:1"}}
{"file": "parallel-programming/dataparallelsim.cpp", "prefix": "#include <iostream>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <limits>\n#include <omp.h>\n\nusing namespace std;\n\nint V = 30;\nint selA = 15;\nint ENOUGH_STATES = 10000;\n\n\nstatic int  g_bestCost  = numeric_limits<int>::max();\nstatic vector<int> g_bestFlags;\n\nclass Graph {\n    int V;\n    vector<vector<pair<int,int>>> adjList;\n    vector<vector<int>> edgeCosts;\n\npublic:\n    explicit Graph(int V) : V(V) {\n        adjList.resize(V);\n        edgeCosts.resize(V, vector<int>(V, 0));\n    }\n\n    void addEdge(int u, int v, int w) {\n        adjList[u].emplace_back(v, w);\n        edgeCosts[u][v] = w;\n    }\n    const vector<pair<int, int>>& getEdges(int u) const {\n        return adjList[u];\n    }\n    int getEdgeCost(int u, int v) const {\n        return edgeCosts[u][v];\n    }\n    int getVertexCount() const {\n        return V;\n    }\n    void printGraph() {\n        for (int i = 0; i < V; ++i) {\n            cout << \"Vertex \" << i << \":\";\n            for (auto &edge : adjList[i]) {\n                cout << \" -> (\" << edge.first << \", weight: \" << edge.second << \")\";\n            }\n            cout << endl;\n        }\n    }\n};\n\nstruct BnBState {\n    vector<int> flags;\n    int index;\n    int countA;\n    int cost;\n};\n\nvoid loadFile(const string& fileName, Graph &G) {\n    ifstream infile(fileName);\n    if (!infile) {\n        cerr << \"Error opening file: \" << fileName << endl;\n        exit(1);\n    }\n\n    string line;\n    getline(infile, line);\n\n    vector<vector<int>> matrix;\n    while (getline(infile, line)) {\n        stringstream ss(line);\n        vector<int> row;\n        int value;\n        while (ss >> value) {\n            row.push_back(value);\n        }\n        matrix.push_back(row);\n    }\n\n    int size = (int)matrix.size();\n    for(int i=0; i<size; ++i) {\n        for(int j=0; j<size; ++j) {\n            if(matrix[i][j] != 0 && i<j) {\n                G.addEdge(i, j, matrix[i][j]);\n            }\n        }\n    }\n}\n\nint calculateCost(const Graph &G, const vector<int> &flags, int node, int flag) {\n    // Same as task parallel\n    int cost = 0;\n    const auto &neighbors = G.getEdges(node);\n    for (auto &nbr : neighbors) {\n        int nnode  = nbr.first;\n        int weight = nbr.second;\n        if (flags[nnode] != -1 && flags[nnode] != flag) {\n            cost += weight;\n        }\n    }\n    for (int i = 0; i < node; ++i) {\n        if (flags[i] != -1 && flags[i] != flag) {\n            cost += G.getEdgeCost(i, node);\n        }\n    }\n    return cost;\n}\n\n\nvoid resAlmostSeqSubTree(const Graph &G, vector<int> &flags, int index, int countA, int currentCost)\n{\n    // almost same as task parallel\n    if (currentCost >= g_bestCost) return;\n    if (countA > selA || (countA + (V - index)) < selA) return;\n\n    if (index == V) {\n        #pragma omp critical\n        {\n            if (currentCost < g_bestCost) {\n                g_bestCost  = currentCost;\n                g_bestFlags = flags;\n            }\n        }\n        return;\n    }\n\n    flags[index] = 0;\n    {\n        int cInc = calculateCost(G, flags, index, 0);\n        resAlmostSeqSubTree(G, flags, index + 1, countA + 1, currentCost + cInc);\n    }\n\n    flags[index] = 1;\n    {\n        int cInc = calculateCost(G, flags, index, 1);\n        resAlmostSeqSubTree(G, flags, index + 1, countA, currentCost + cInc);\n    }\n\n    flags[index] = -1;\n}\n\nvector<BnBState> buildPartialStates(const Graph &G, int enoughStates, int maxDepth) {\n    vector<BnBState> result;\n    queue<BnBState> Q;\n\n    BnBState init;\n    init.flags  = vector<int>(V, -1);\n    init.index  = 0;\n    init.countA = 0;\n    init.cost   = 0;\n    Q.push(init);\n\n    while (!Q.empty()) {\n        BnBState s = Q.front();\n        Q.pop();\n\n        if (s.index >= maxDepth || s.index == V) {\n            result.push_back(s);\n        }\n        else {\n            {\n                BnBState s0 = s;\n                s0.flags[s0.index] = 0;\n                int cInc = calculateCost(G, s0.flags, s0.index, 0);\n                s0.cost   += cInc;\n                s0.countA += 1;\n                s0.index  += 1;\n                // Prune\n                if (s0.cost < g_bestCost && s0.countA <= selA) {\n                    Q.push(s0);\n                }\n            }\n\n            {\n                BnBState s1 = s;\n                s1.flags[s1.index] = 1;\n                int cInc = calculateCost(G, s1.flags, s1.index, 1);\n                s1.cost  += cInc;\n                s1.index += 1;\n                // Prune\n                if (s1.cost < g_bestCost) {\n                    Q.push(s1);\n                }\n            }\n        }\n\n", "suffix": "\n    }\n\n    return result;\n}\n\nint main() {\n    Graph g(V);\n    loadFile(\"data/graf_30_20.txt\", g);\n\n    g.printGraph();\n\n    g_bestFlags.resize(V, -1);\n\n    double start = omp_get_wtime();\n\n    // BFS\n    int BFS_DEPTH = 8;\n    vector<BnBState> partialStates = buildPartialStates(g, ENOUGH_STATES, BFS_DEPTH);\n\n    cout << \"Generated \" << partialStates.size()\n         << \" partial states from BFS.\\n\";\n\n    // recursion on each partial state\n    #pragma omp parallel for schedule(dynamic)\n    for (int i = 0; i < (int)partialStates.size(); i++) {\n        BnBState st = partialStates[i];\n        // weird result one time, so i created a local variable instead of directly passing st.flags\n        vector<int> localFlags = st.flags;\n        resAlmostSeqSubTree(g, localFlags, st.index, st.countA, st.cost);\n    }\n\n    double stop = omp_get_wtime();\n\n    cout << \"\\nMinimum cut cost: \" << g_bestCost << endl;\n    cout << \"\\nTime: \" << (stop - start) << \" seconds\\n\";\n\n    return 0;\n}\n", "middle": "        if ((int)result.size() >= enoughStates) break;", "meta": {"lines": "190:1-190:55"}}
